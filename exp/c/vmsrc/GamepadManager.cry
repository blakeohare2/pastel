
function @type('GamepadStatus') gamepadGetGlobalStatus() {
	@type('ProgramData') p = $_get_program_data();
	return ProgramData$p.gamepadStatus;
}

function @type('string') gamepadGenerateFingerprint(
		@type('string') deviceName,
		@type('int') analogAxisCount,
		@type('int') digital2dAxisCount,
		@type('int') buttonCount) {
	if (%%%IS_GAMEPAD_SUPPORTED%%%) {
		return stringToHex($_string_trim(deviceName)) + "-" +
			$_string_cast_weak(analogAxisCount) + "-" +
			$_string_cast_weak(digital2dAxisCount) + "-" +
			$_string_cast_weak(buttonCount);
	} else {
		return "";
	}
}

/*
	This is invoked directly after the game window has been initialized.
	Output not used.
*/
function @type('bool') gamepadInitializeState() {

	@type('GamepadStatus') status = gamepadGetGlobalStatus();

	if (%%%IS_GAMEPAD_SUPPORTED%%%) {
		@type('bool') isInitialized = GamepadStatus$status.isInitialized;
		if (isInitialized) {
			return false;
		}

		@type('List<GamepadDeviceInfo>') deviceList = GamepadStatus$status.devices;
		@type('List<Value>') deviceValueList = GamepadStatus$status.deviceValues;

		@type('GamepadHardwarePushy') hardwarePushy = null;
		@type('List<GamepadHardwarePushy>') hardwarePushies = GamepadStatus$status.hardwarePushies;
		@type('List<GamepadAtomicPushy>') atomicPushies = GamepadStatus$status.atomicPushies;

		@type('int') index = 0;
		@type('int') deviceCount = $_gamepad_get_device_count();
		for (@type('int') deviceIndex = 0; deviceIndex < deviceCount; deviceIndex += 1) {

			// TODO: just combine these two into a $_gamepad_get_initialized_device(deviceIndex)
			@type('object') nativeDevice = $_gamepad_get_device(deviceIndex);
			$_gamepad_initialize(nativeDevice, deviceIndex);

			@type('string') deviceName = $_gamepad_get_device_name(nativeDevice, deviceIndex);
			@type('int') analogAxisCount = $_gamepad_get_analog_axis_count(nativeDevice, deviceIndex);
			@type('int') digital2dAxisCount = $_gamepad_get_2d_digital_axis_count(nativeDevice, deviceIndex);
			@type('int') buttonCount = $_gamepad_get_button_count(nativeDevice, deviceIndex);
			@type('string') deviceFingerprint = gamepadGenerateFingerprint(deviceName, analogAxisCount, digital2dAxisCount, buttonCount);

			@type('GamepadDeviceInfo') deviceInfo = new GamepadDeviceInfo(
				deviceIndex,
				nativeDevice,
				deviceName,
				deviceFingerprint, // config fingerprint

				null, // player ID

				analogAxisCount, // analog axis count
				digital2dAxisCount, // digital axis count
				buttonCount, // button count

				0, // hardware pushy start index
				0, // hardware pushy count
				0, // atomic pushy start index
				0, // atomic pushy count

				$_new_dictionary('string', 'GamepadVirtualPushy'),
				$_new_dictionary('int', 'GamepadVirtualPushy'),
				$_new_list('string'),
				$_new_list('int')
				);
			$_list_push(deviceList, deviceInfo);
			$_list_push(deviceValueList, 
				new Value(Types.NATIVE_OBJECT, new NativeObjectWrapper(NativeObjectSubType.GAMEPAD_DEVICE, deviceInfo)));

			@type('int') i = 0;

			@type('int') hardwarePushyStartLength = $_list_length(hardwarePushies);
			@type('int') atomicPushyStartLength = $_list_length(atomicPushies);

			for (i = 0; i < buttonCount; i += 1) {
				hardwarePushy = new GamepadHardwarePushy(
					deviceIndex,
					0, // is button
					i, // hardware index
					false, 0.0, 0, 0, // starting state
					0, 0, 0, 0, 0, 0, 0); // game counters
		
				index = $_list_length(hardwarePushies);
				$_list_push(hardwarePushies, hardwarePushy);
		
				$_list_push(atomicPushies, new GamepadAtomicPushy(index, 0, false, 0.0, 0, "B:" + $_string_cast_weak(i), false));
			}

			for (i = 0; i < analogAxisCount; i += 1) {
				hardwarePushy = new GamepadHardwarePushy(
					deviceIndex,
					1, // is analog axis
					i, // hardware index
					false, 0.0, 0, 0, // starting state
					0, 0, 0, 0, 0, 0, 0); // game counters
		
				index = $_list_length(hardwarePushies);
				$_list_push(hardwarePushies, hardwarePushy);
				$_list_push(atomicPushies, new GamepadAtomicPushy(index, 1, false, 0.0, 0, "A:" + $_string_cast_weak(i) + ":1", false));
				$_list_push(atomicPushies, new GamepadAtomicPushy(index, 2, false, 0.0, 0, "A:" + $_string_cast_weak(i) + ":0", false));
			}
	
			for (i = 0; i < digital2dAxisCount; i += 1) {
				hardwarePushy = new GamepadHardwarePushy(
					deviceIndex,
					2, // is analog axis
					i, // hardware index
					false, 0.0, 0, 0, // starting state
					0, 0, 0, 0, 0, 0, 0); // game counters
		
				index = $_list_length(hardwarePushies);
				$_list_push(hardwarePushies, hardwarePushy);
				$_list_push(atomicPushies, new GamepadAtomicPushy(index, 3, false, 0.0, 0, "D:" + $_string_cast_weak(i) + ":X:1", false));
				$_list_push(atomicPushies, new GamepadAtomicPushy(index, 4, false, 0.0, 0, "D:" + $_string_cast_weak(i) + ":X:0", false));
				$_list_push(atomicPushies, new GamepadAtomicPushy(index, 5, false, 0.0, 0, "D:" + $_string_cast_weak(i) + ":Y:1", false));
				$_list_push(atomicPushies, new GamepadAtomicPushy(index, 6, false, 0.0, 0, "D:" + $_string_cast_weak(i) + ":Y:0", false));
			}
	
			@type('int') hardwarePushyEndLength = $_list_length(hardwarePushies);
			@type('int') atomicPushyEndLength = $_list_length(atomicPushies);

			GamepadDeviceInfo$deviceInfo.hardwarePushyStartIndex = hardwarePushyStartLength;
			GamepadDeviceInfo$deviceInfo.hardwarePushyCount = hardwarePushyEndLength - hardwarePushyStartLength;
			GamepadDeviceInfo$deviceInfo.atomicPushyStartIndex = atomicPushyStartLength;
			GamepadDeviceInfo$deviceInfo.atomicPushyCount = atomicPushyEndLength - atomicPushyStartLength;
		}
	}

	GamepadStatus$status.isInitialized = true;
	return true;
}

/*
	Set an ID on a gamepad device (or clear it if null is passed in)
	If a non-null ID is already set 
	Error codes:
	0 - no error
	1 - not a device
	2 - bad ID
*/
function @type('int') gamepadSetId(@type('Value') deviceValue, @type('Value') idValue) {
	if (%%%IS_GAMEPAD_SUPPORTED%%%) {
		@type('GamepadDeviceInfo') device = $_cast('GamepadDeviceInfo', extractNativeObjectOfType(deviceValue, NativeObjectSubType.GAMEPAD_DEVICE));
		if (device == null) {
			return 1;
		}
		if (idValue == null || Value$idValue.type == Types.NULL) {
			GamepadDeviceInfo$device.playerId = null;
			return 0;
		}
		if (Value$idValue.type != Types.INTEGER && Value$idValue.type != Types.STRING) {
			return 2;
		}

		@type('GamepadStatus') status = gamepadGetGlobalStatus();
		
		@type('List<GamepadDeviceInfo>') devices = GamepadStatus$status.devices;
		
		for (@type('int') i = 0; i < $_list_length(devices); i += 1) {
			@type('GamepadDeviceInfo') otherDevice = $_list_get(devices, i);
			@type('Value') otherId = GamepadDeviceInfo$otherDevice.playerId;
			if (otherId != null && Value$otherId.type == Value$idValue.type) {
				if (Value$idValue.type == Types.INTEGER) {
					if ($_cast('int', Value$idValue.internalValue) == $_cast('int', Value$otherId.internalValue)) {
						GamepadDeviceInfo$otherDevice.playerId = null;
					}
				} else { // Types.STRING
					if ($_string_equals($_cast('string', Value$idValue.internalValue), $_cast('string', Value$otherId.internalValue))) {
						GamepadDeviceInfo$otherDevice.playerId = null;
					}
				}
			}
		}

		GamepadDeviceInfo$device.playerId = idValue;

		return 0;
	} else {
		return 1;
	}
}

function @type('bool') gamepadClearIds() {
	@type('GamepadStatus') status = gamepadGetGlobalStatus();
	@type('bool') isInitialized = GamepadStatus$status.isInitialized;
	if (!isInitialized) {
		return true;
	}

	if (%%%IS_GAMEPAD_SUPPORTED%%%) {
		// Note that clearing the player ID should NOT clear the virtual bindings, though.
		@type('List<GamepadDeviceInfo>') devices = GamepadStatus$status.devices;
		for (@type('int') i = 0; i < $_list_length(devices); i += 1) {
			@type('GamepadDeviceInfo') device = $_list_get(devices, i);
			GamepadDeviceInfo$device.playerId = null;
		}
	}

	return false;
}

/*
	Status codes:
	0 - not bound
	1 - bound
	2 - device invalid
	3 - descriptor invalid
	4 - alias isn't suitable type
	5 - direction invalid
	6 - sign invalid

	Valid descriptor strings:
	B:# -- button #
	A:#:0|1 -- analog axis # in the 0-negative/1-positive direction
	D:#:X|Y:0|1 -- digital axis # along the X/Y axis in the 0-neg/1-pos direction

	If this particular descriptor is already used, then the pushy must not be bound and 0 returned.
	If this user action is already bound, then that's okay as this will automatically overwrite that.
*/
function @type('int') gamepadBind(
	@type('Value') deviceValue,
	@type('Value') descriptorValue,
	@type('Value') alias,
	@type('int') dimensionality,
	@type('Value') isPositiveValue,
	@type('Value') isXValue,
	@type('bool') isDigital) {
	
	if (%%%IS_GAMEPAD_SUPPORTED%%%) {
		@type('GamepadDeviceInfo') device = $_cast('GamepadDeviceInfo', extractNativeObjectOfType(deviceValue, NativeObjectSubType.GAMEPAD_DEVICE));
		if (device == null) {
			return 2;
		}
		if (Value$descriptorValue.type != Types.STRING) return 3;
		@type('string') descriptor = $_cast('string', Value$descriptorValue.internalValue);

		// Look through atomic pushies for the one with the same descriptor ID.
		@type('GamepadStatus') status = gamepadGetGlobalStatus();
		@type('int') atomicPushyStartIndex = GamepadDeviceInfo$device.atomicPushyStartIndex;
		@type('int') atomicPushyEndIndex = atomicPushyStartIndex + GamepadDeviceInfo$device.atomicPushyCount;
		@type('List<GamepadAtomicPushy>') atomicPushies = GamepadStatus$status.atomicPushies;
		@type('GamepadAtomicPushy') atomicPushy = null;
		@type('int') atomicPushyFoundIndex = -1;
		for (@type('int') i = atomicPushyStartIndex; i < atomicPushyEndIndex; i += 1) {
			@type('GamepadAtomicPushy') atomicPushyIterator = $_list_get(atomicPushies, i);
			if ($_string_equals(GamepadAtomicPushy$atomicPushyIterator.descriptorId, descriptor)) {
				atomicPushy = atomicPushyIterator;
				atomicPushyFoundIndex = i;
				i = atomicPushyEndIndex; // break;
			}
		}
		if (atomicPushy == null) {
			return 3;
		}

		if (GamepadAtomicPushy$atomicPushy.isConfigured) {
			return 0; // Pushy already in use. Don't double-configure.
		}
		GamepadAtomicPushy$atomicPushy.isConfigured = true;

		@type('GamepadVirtualPushy') virtualPushy = null;
		if (Value$alias.type == Types.INTEGER) {
			@type('int') virtualIdInt = $_cast('int', Value$alias.internalValue);
			if ($_dictionary_contains(GamepadDeviceInfo$device.intVirtualPushies, virtualIdInt)) {
				virtualPushy = $_dictionary_get_guaranteed(GamepadDeviceInfo$device.intVirtualPushies, virtualIdInt);
			} else {
				virtualPushy = new GamepadVirtualPushy(buildInteger(virtualIdInt), dimensionality, false, -1, -1, -1, -1, -1);
				$_dictionary_set(GamepadDeviceInfo$device.intVirtualPushies, virtualIdInt, virtualPushy);
				$_list_push(GamepadDeviceInfo$device.intVirtualPushyIds, virtualIdInt);
			}
		} else if (Value$alias.type == Types.STRING) {
			@type('string') virtualIdString = $_cast('string', Value$alias.internalValue);
			if ($_dictionary_contains(GamepadDeviceInfo$device.stringVirtualPushies, virtualIdString)) {
				virtualPushy = $_dictionary_get_guaranteed(GamepadDeviceInfo$device.stringVirtualPushies, virtualIdString);
			} else {
				virtualPushy = new GamepadVirtualPushy(buildString(virtualIdString), dimensionality, false, -1, -1, -1, -1, -1);
				$_dictionary_set(GamepadDeviceInfo$device.stringVirtualPushies, virtualIdString, virtualPushy);
				$_list_push(GamepadDeviceInfo$device.stringVirtualPushyIds, virtualIdString);
			}
		} else {
			return 4;
		}

		// Overwrite any previous digital vs analog value with latest.
		GamepadVirtualPushy$virtualPushy.isDigital = isDigital;

		@type('bool') isX = false;
		@type('bool') isPositive = false;
		if (isXValue != null) {
			if (Value$isXValue.type != Types.BOOLEAN) return 6;
			isX = $_cast('bool', Value$isXValue.internalValue);
		}

		if (isPositiveValue != null) {
			if (Value$isPositiveValue.type != Types.BOOLEAN) return 5;
			isPositive = $_cast('bool', Value$isPositiveValue.internalValue);
		}

		@type('int') bumpedIndex = -1;

		if (dimensionality == 0) {
			bumpedIndex = GamepadVirtualPushy$virtualPushy.atomicIndex1;
			GamepadVirtualPushy$virtualPushy.atomicIndex1 = atomicPushyFoundIndex;
		} else if (dimensionality == 1) {
			if (isPositive) {
				bumpedIndex = GamepadVirtualPushy$virtualPushy.atomicIndex1;
				GamepadVirtualPushy$virtualPushy.atomicIndex1 = atomicPushyFoundIndex;
			} else {
				bumpedIndex = GamepadVirtualPushy$virtualPushy.atomicIndex2;
				GamepadVirtualPushy$virtualPushy.atomicIndex2 = atomicPushyFoundIndex;
			}
		} else { // dimensionality == 2
			if (isX) {
				if (isPositive) {
					bumpedIndex = GamepadVirtualPushy$virtualPushy.atomicIndex1;
					GamepadVirtualPushy$virtualPushy.atomicIndex1 = atomicPushyFoundIndex;
				} else {
					bumpedIndex = GamepadVirtualPushy$virtualPushy.atomicIndex2;
					GamepadVirtualPushy$virtualPushy.atomicIndex2 = atomicPushyFoundIndex;
				}
			} else {
				if (isPositive) {
					bumpedIndex = GamepadVirtualPushy$virtualPushy.atomicIndex3;
					GamepadVirtualPushy$virtualPushy.atomicIndex3 = atomicPushyFoundIndex;
				} else {
					bumpedIndex = GamepadVirtualPushy$virtualPushy.atomicIndex4;
					GamepadVirtualPushy$virtualPushy.atomicIndex4 = atomicPushyFoundIndex;
				}
			}
		}

		// if you bumped another atomic pushy that was previously configured, then you need to notate it
		// in the atomic pushy value.
		if (bumpedIndex != -1) {
			atomicPushy = $_list_get(atomicPushies, bumpedIndex);
			GamepadAtomicPushy$atomicPushy.isConfigured = false;
		}

		return 1;
	} else {
		return 2;
	}
}

function @type('bool') gamepadPollBeginFrame() {
	
	if (%%%IS_GAMEPAD_SUPPORTED%%%) {
		@type('ProgramData') programData = $_get_program_data();
		@type('int') gameCounter = ProgramData$programData.gameCounter;
		@type('GamepadStatus') status = gamepadGetGlobalStatus();
		$_list_clear(GamepadStatus$status.hardwareEvents);

		if (!GamepadStatus$status.isInitialized) {
			return true;
		}

		$_gamepad_poll();

		@type('List<GamepadDeviceInfo>') devices = GamepadStatus$status.devices;
		@type('List<GamepadHardwarePushy>') hardwarePushies = GamepadStatus$status.hardwarePushies;
		@type('List<GamepadAtomicPushy>') atomicPushies = GamepadStatus$status.atomicPushies;
		@type('GamepadHardwarePushy') hardwarePushy = null;
		@type('GamepadAtomicPushy') atomicPushy = null;
		@type('int') j = 0;
		@type('int') pushyType = 0;
		@type('int') pushySubType = 0;
		@type('int') hardwareIndex = 0;

		@type('bool') oldPushed = false;
		@type('bool') newPushed = false;
		@type('double') oldAxis = 0.0;
		@type('double') newAxis = 0.0;
		@type('double') axisDiff = 0.0;
		@type('int') oldX = 0;
		@type('int') newX = 0;
		@type('int') oldY = 0;
		@type('int') newY = 0;
		@type('Array<int>') xy = null;

		@type('Value') devicePlayerId = null;

		for (@type('int') i = 0; i < $_list_length(devices); i += 1) {
			@type('GamepadDeviceInfo') device = $_list_get(devices, i);
			if (GamepadDeviceInfo$device.playerId != null) {
				
				// First pass: update the hardware pushies.
				@type('int') pushyStart = GamepadDeviceInfo$device.hardwarePushyStartIndex;
				@type('int') pushyEnd = pushyStart + GamepadDeviceInfo$device.hardwarePushyCount;
				for (j = pushyStart; j < pushyEnd; j += 1) {
					hardwarePushy = $_list_get(hardwarePushies, j);
					pushyType = GamepadHardwarePushy$hardwarePushy.type;
					hardwareIndex = GamepadHardwarePushy$hardwarePushy.hardwareIndex;
					if (pushyType == 0) {
						// Button
						oldPushed = GamepadHardwarePushy$hardwarePushy.buttonValue;
						newPushed = $_gamepad_get_button_value(GamepadDeviceInfo$device.nativeDevice, hardwareIndex);
						if (oldPushed != newPushed) {
							GamepadHardwarePushy$hardwarePushy.buttonValue = newPushed;
							GamepadHardwarePushy$hardwarePushy.buttonGameCounter = gameCounter;
						}
					} else if (pushyType == 1) {
						// 1D Analog Axis
						oldAxis = GamepadHardwarePushy$hardwarePushy.axisValue;
						newAxis = $_gamepad_get_analog_axis_value(GamepadDeviceInfo$device.nativeDevice, hardwareIndex);
						if (newAxis < -.99) newAxis = -1.0;
						else if (newAxis > .99) newAxis = 1.0;
						else if (newAxis < .01 && newAxis > -.01) newAxis = 0.0;

						axisDiff = newAxis - oldAxis;
						if (axisDiff < 0) axisDiff *= -1;

						if (axisDiff >= 0.001) {

							// determine sign changes
							if (oldAxis < 0) oldX = -1;
							else if (oldAxis > 0) oldX = 1;
							else oldX = 0;

							if (newAxis < 0) newX = -1;
							else if (newAxis > 0) newX = 1;
							else newX = 0;

							if (oldX == 0) {
								// Went from 0 to something else. Only fire a notification for the new axis sign.
								if (newX > 0) GamepadHardwarePushy$hardwarePushy.axisPositiveGameCounter = gameCounter;
								else GamepadHardwarePushy$hardwarePushy.axisNegativeGameCounter = gameCounter;
							} else if (newX == 0 || newX == oldX) {
								// Went from something to 0 OR sign didn't change. Only fire notification for the old axis sign.
								if (oldX > 0) GamepadHardwarePushy$hardwarePushy.axisPositiveGameCounter = gameCounter;
								else GamepadHardwarePushy$hardwarePushy.axisNegativeGameCounter = gameCounter;
							} else {
								// sign changed. Fire notification for both signs. 
								GamepadHardwarePushy$hardwarePushy.axisPositiveGameCounter = gameCounter;
								GamepadHardwarePushy$hardwarePushy.axisNegativeGameCounter = gameCounter;
							}

							GamepadHardwarePushy$hardwarePushy.axisValue = newAxis;
						}
					} else if (pushyType == 2) {
						// 2D Digital Axis
						oldX = GamepadHardwarePushy$hardwarePushy.hatXValue;
						oldY = GamepadHardwarePushy$hardwarePushy.hatYValue;
						xy = $_gamepad_get_2d_digital_axis_value(GamepadDeviceInfo$device.nativeDevice, hardwareIndex);
						newX = $_array_get(xy, 0);
						newY = $_array_get(xy, 1);
						if (oldX != newX || oldY != newY) {
							if ((oldX == -1) != (newX == -1)) {
								// -X changed
								GamepadHardwarePushy$hardwarePushy.hatXNegativeGameCounter = gameCounter;
							}
							if ((oldX == 1) != (newX == 1)) {
								// +X changed
								GamepadHardwarePushy$hardwarePushy.hatXPositiveGameCounter = gameCounter;
							}
							if ((oldY == -1) != (newY == -1)) {
								// -Y changed
								GamepadHardwarePushy$hardwarePushy.hatYNegativeGameCounter = gameCounter;
							}
							if ((oldY == 1) != (newY == 1)) {
								// +Y changed
								GamepadHardwarePushy$hardwarePushy.hatYPositiveGameCounter = gameCounter;
							}
							GamepadHardwarePushy$hardwarePushy.hatXValue = newX;
							GamepadHardwarePushy$hardwarePushy.hatYValue = newY;
						}
					}
				}

				// Second pass: update the atomic pushies and fire hardware events
				pushyStart = GamepadDeviceInfo$device.atomicPushyStartIndex;
				pushyEnd = pushyStart + GamepadDeviceInfo$device.atomicPushyCount;
				for (j = pushyStart; j < pushyEnd; j += 1) {
					atomicPushy = $_list_get(atomicPushies, j);
					hardwareIndex = GamepadAtomicPushy$atomicPushy.hardwarePushyIndex;
					hardwarePushy = $_list_get(hardwarePushies, hardwareIndex);
					pushyType = GamepadHardwarePushy$hardwarePushy.type;
					if (pushyType == 0) {
						if (GamepadHardwarePushy$hardwarePushy.buttonGameCounter == gameCounter) {
							// Fire button event
							newPushed = GamepadHardwarePushy$hardwarePushy.buttonValue;
							GamepadAtomicPushy$atomicPushy.value = newPushed;
							GamepadAtomicPushy$atomicPushy.gameCounter = gameCounter;
							gamepadFireDigitalEvent(status, i, devicePlayerId, GamepadAtomicPushy$atomicPushy.descriptorId, newPushed, false);
						}
					} else if (pushyType == 1) {
						pushySubType = GamepadAtomicPushy$atomicPushy.subtype;
						if (pushySubType == 1) { // positive axis
							if (GamepadHardwarePushy$hardwarePushy.axisPositiveGameCounter == gameCounter) {
								newAxis = GamepadHardwarePushy$hardwarePushy.axisValue;
								GamepadAtomicPushy$atomicPushy.valueF = newAxis;
								GamepadAtomicPushy$atomicPushy.gameCounter = gameCounter;
								gamepadFireAnalogEvent(status, i, devicePlayerId, GamepadAtomicPushy$atomicPushy.descriptorId, newAxis);
							}
						} else { // negative axis
							if (GamepadHardwarePushy$hardwarePushy.axisNegativeGameCounter == gameCounter) {
								newAxis = -GamepadHardwarePushy$hardwarePushy.axisValue;
								GamepadAtomicPushy$atomicPushy.valueF = newAxis;
								GamepadAtomicPushy$atomicPushy.gameCounter = gameCounter;
								gamepadFireAnalogEvent(status, i, devicePlayerId, GamepadAtomicPushy$atomicPushy.descriptorId, newAxis);
							}
						}
					} else if (pushyType == 2) {
						pushySubType = GamepadAtomicPushy$atomicPushy.subtype;
						if (pushySubType == 3) { // X+
							if (GamepadHardwarePushy$hardwarePushy.hatXPositiveGameCounter == gameCounter) {
								newPushed = GamepadHardwarePushy$hardwarePushy.hatXValue > 0;
								GamepadAtomicPushy$atomicPushy.value = newPushed;
								GamepadAtomicPushy$atomicPushy.gameCounter = gameCounter;
								gamepadFireDigitalEvent(status, i, devicePlayerId, GamepadAtomicPushy$atomicPushy.descriptorId, newPushed, true);
							}
						} else if (pushySubType == 4) { // X-
							if (GamepadHardwarePushy$hardwarePushy.hatXNegativeGameCounter == gameCounter) {
								newPushed = GamepadHardwarePushy$hardwarePushy.hatXValue < 0;
								GamepadAtomicPushy$atomicPushy.value = newPushed;
								GamepadAtomicPushy$atomicPushy.gameCounter = gameCounter;
								gamepadFireDigitalEvent(status, i, devicePlayerId, GamepadAtomicPushy$atomicPushy.descriptorId, newPushed, true);
							}
						} else if (pushySubType == 5) { // Y+
							if (GamepadHardwarePushy$hardwarePushy.hatYPositiveGameCounter == gameCounter) {
								newPushed = GamepadHardwarePushy$hardwarePushy.hatYValue > 0;
								GamepadAtomicPushy$atomicPushy.value = newPushed;
								GamepadAtomicPushy$atomicPushy.gameCounter = gameCounter;
								gamepadFireDigitalEvent(status, i, devicePlayerId, GamepadAtomicPushy$atomicPushy.descriptorId, newPushed, true);
							}
						} else { // Y-
							if (GamepadHardwarePushy$hardwarePushy.hatYNegativeGameCounter == gameCounter) {
								newPushed = GamepadHardwarePushy$hardwarePushy.hatYValue < 0;
								GamepadAtomicPushy$atomicPushy.value = newPushed;
								GamepadAtomicPushy$atomicPushy.gameCounter = gameCounter;
								gamepadFireDigitalEvent(status, i, devicePlayerId, GamepadAtomicPushy$atomicPushy.descriptorId, newPushed, true);
							}
						}
					}
				}

				// Now search for virtual pushy events and add them to the event queue.
				@type('int') intIterator = 0;
				@type('int') stringIterator = 0;
				@type('int') intVLength = $_list_length(GamepadDeviceInfo$device.intVirtualPushyIds);
				@type('int') stringVLength = $_list_length(GamepadDeviceInfo$device.stringVirtualPushyIds);
				@type('GamepadVirtualPushy') virtualPushy = null;
				@type('bool') needsFiring = false;
				@type('int') dimensionality = 0;
				@type('int') atomicPushyIndex = 0;
				@type('GamepadAtomicPushy') ap1 = null;
				@type('GamepadAtomicPushy') ap2 = null;
				@type('GamepadAtomicPushy') ap3 = null;
				@type('GamepadAtomicPushy') ap4 = null;
		

				while (intIterator + stringIterator < intVLength + stringVLength) {
					if (intIterator < intVLength) {
						virtualPushy = $_dictionary_get_guaranteed(GamepadDeviceInfo$device.intVirtualPushies, $_list_get(GamepadDeviceInfo$device.intVirtualPushyIds, intIterator));
						intIterator += 1;
					} else {
						virtualPushy = $_dictionary_get_guaranteed(GamepadDeviceInfo$device.stringVirtualPushies, $_list_get(GamepadDeviceInfo$device.stringVirtualPushyIds, stringIterator));
						stringIterator += 1;
					}

					needsFiring = false;
					dimensionality = GamepadVirtualPushy$virtualPushy.dimensionality;
					
					// atomic pushy 1
					atomicPushyIndex = GamepadVirtualPushy$virtualPushy.atomicIndex1;
					if (atomicPushyIndex != -1) {
						ap1 = $_list_get(atomicPushies, atomicPushyIndex);
						if (GamepadAtomicPushy$ap1.gameCounter == gameCounter) {
							needsFiring = true;
						}
					} else {
						ap1 = null;
					}

					if (dimensionality > 0) {
						// atomic pushy 2
						atomicPushyIndex = GamepadVirtualPushy$virtualPushy.atomicIndex2;
						if (atomicPushyIndex != -1) {
							ap2 = $_list_get(atomicPushies, atomicPushyIndex);
							if (GamepadAtomicPushy$ap2.gameCounter == gameCounter) {
								needsFiring = true;
							}
						} else {
							ap2 = null;
						}

						if (dimensionality > 1) {
							// atomic pushy 3
							if (dimensionality > 1) {
								atomicPushyIndex = GamepadVirtualPushy$virtualPushy.atomicIndex3;
								if (atomicPushyIndex != -1) {
									ap3 = $_list_get(atomicPushies, atomicPushyIndex);
									if (GamepadAtomicPushy$ap3.gameCounter == gameCounter) {
										needsFiring = true;
									}
								} else {
									ap3 = null;
								}
							}

							// atomic pushy 4
							if (dimensionality > 1) {
								atomicPushyIndex = GamepadVirtualPushy$virtualPushy.atomicIndex4;
								if (atomicPushyIndex != -1) {
									ap4 = $_list_get(atomicPushies, atomicPushyIndex);
									if (GamepadAtomicPushy$ap4.gameCounter == gameCounter) {
										needsFiring = true;
									}
								} else {
									ap4 = null;
								}
							}
						}
					}

					if (needsFiring) {
						// TODO (bug) analog values bound as digital events will needlessly fire as the analog value changes without crossing the firing threshold.
						gamepadFireVirtualEvent(virtualPushy, gameCounter, status, i, GamepadVirtualPushy$virtualPushy.alias, dimensionality, GamepadVirtualPushy$virtualPushy.isDigital, ap1, ap2, ap3, ap4);
					}
				}
			}
		}
	}
	return true;
}

function @type('Value') gamepadGetVirtualPushyValueWithIndex(
		@type('int') dimensionality,
		@type('bool') isDigital,
		@type('int') ap1,
		@type('int') ap2,
		@type('int') ap3,
		@type('int') ap4) {
	if (%%%IS_GAMEPAD_SUPPORTED%%%) {
		@type('GamepadStatus') gamepadStatus = gamepadGetGlobalStatus();
		@type('List<GamepadAtomicPushy>') atomicPushies = GamepadStatus$gamepadStatus.atomicPushies;
		@type('GamepadAtomicPushy') ap1Inst = null;
		@type('GamepadAtomicPushy') ap2Inst = null;
		@type('GamepadAtomicPushy') ap3Inst = null;
		@type('GamepadAtomicPushy') ap4Inst = null;
		if (ap1 != -1) ap1Inst = $_list_get(atomicPushies, ap1);
		if (ap2 != -1) ap2Inst = $_list_get(atomicPushies, ap2);
		if (ap3 != -1) ap3Inst = $_list_get(atomicPushies, ap3);
		if (ap4 != -1) ap4Inst = $_list_get(atomicPushies, ap4);
		return gamepadGetVirtualPushyValue(dimensionality, isDigital, ap1Inst, ap2Inst, ap3Inst, ap4Inst);
	} else {
		return null;
	}
}

function @type('Value') gamepadGetVirtualPushyValue(
		@type('int') dimensionality,
		@type('bool') isDigital,
		@type('GamepadAtomicPushy') ap1,
		@type('GamepadAtomicPushy') ap2,
		@type('GamepadAtomicPushy') ap3,
		@type('GamepadAtomicPushy') ap4) {

	if (%%%IS_GAMEPAD_SUPPORTED%%%) {
		@type('Value') value = null;
		if (dimensionality == 0) {
			@type('int') ap1type = GamepadAtomicPushy$ap1.subtype;
			if (ap1type == 1 || ap1type == 2) {
				if (isDigital) {
					if (GamepadAtomicPushy$ap1.valueF > .5) {
						value = VALUE_TRUE;
					} else {
						value = VALUE_FALSE;
					}
				} else {
					value = buildFloat(GamepadAtomicPushy$ap1.valueF);
				}
			} else {
				if (GamepadAtomicPushy$ap1.value) {
					if (isDigital) {
						value = VALUE_TRUE;
					} else {
						value = VALUE_FLOAT_ONE;
					}
				} else {
					if (isDigital) {
						value = VALUE_FALSE;
					} else {
						value = VALUE_FLOAT_ZERO;
					}
				}
			}
		} else {
			if (dimensionality == 1) {
				if (isDigital) {
					value = gamepadBuildVirtualAxisDigitalValue(ap1, ap2);
				} else {
					value = gamepadBuildVirtualAxisAnalogValue(ap1, ap2);
				}
			} else {
				if (isDigital) {
					value = buildList2(gamepadBuildVirtualAxisDigitalValue(ap1, ap2), gamepadBuildVirtualAxisDigitalValue(ap3, ap4));
				} else {
					value = buildList2(gamepadBuildVirtualAxisAnalogValue(ap1, ap2), gamepadBuildVirtualAxisAnalogValue(ap3, ap4));
				}
			}
		}
		return value;
	} else {
		return null;
	}
}

function @type('bool') gamepadFireVirtualEvent(
		@type('GamepadVirtualPushy') virtualPushy,
		@type('int') gameCounter,
		@type('GamepadStatus') status,
		@type('int') deviceIndex,
		@type('Value') alias,
		@type('int') dimensionality,
		@type('bool') isDigital,
		@type('GamepadAtomicPushy') ap1,
		@type('GamepadAtomicPushy') ap2,
		@type('GamepadAtomicPushy') ap3,
		@type('GamepadAtomicPushy') ap4) {
	
	if (%%%IS_GAMEPAD_SUPPORTED%%%) {
		@type('Value') value = gamepadGetVirtualPushyValue(dimensionality, isDigital, ap1, ap2, ap3, ap4);
		@type('GamepadDeviceInfo') device = $_list_get(GamepadStatus$status.devices, deviceIndex);
		@type('Value') playerId = GamepadDeviceInfo$device.playerId;
		if (playerId == null) return true; // sanity check, but this should never happen.
		value = buildGameEventWithExtraArg('gamepad', 'gamepad', deviceIndex, 0, 0.0, false, null, playerId, value, alias);
		$_list_push(GamepadStatus$status.virtualEvents, value);
		GamepadVirtualPushy$virtualPushy.gameCounter = gameCounter;
	}
	return true;
}

function @type('Value') gamepadBuildVirtualAxisDigitalValue(@type('GamepadAtomicPushy') apPos, @type('GamepadAtomicPushy') apNeg) {
	@type('bool') set = false;
	if (apPos != null) {
		if (GamepadAtomicPushy$apPos.subtype == 1) {
			if (GamepadAtomicPushy$apPos.valueF > .5) {
				set = true;
			}
		} else {
			set = GamepadAtomicPushy$apPos.value;
		}
		if (set) return INTEGERS_CACHE[0][1];
	}

	if (apNeg != null) {
		if (GamepadAtomicPushy$apNeg.valueF > .5) {
			if (GamepadAtomicPushy$apNeg.valueF > .5) {
				set = true;
			}
		} else {
			set = GamepadAtomicPushy$apNeg.value;
		}
		if (set) return INTEGERS_CACHE[1][1];
	}

	return INTEGERS_CACHE[0][0];
}

function @type('Value') gamepadBuildVirtualAxisAnalogValue(@type('GamepadAtomicPushy') apPos, @type('GamepadAtomicPushy') apNeg) {
	if (apPos == null || apNeg == null) {
		if (apNeg != null) {
			if (GamepadAtomicPushy$apNeg.subtype == 1 || GamepadAtomicPushy$apNeg.subtype == 2) {
				return buildFloat(-GamepadAtomicPushy$apNeg.valueF);
			}
			if (GamepadAtomicPushy$apNeg.value) {
				return VALUE_FLOAT_NEGATIVE_ONE;
			}
		} else if (apPos != null) {
			if (GamepadAtomicPushy$apPos.subtype == 1 || GamepadAtomicPushy$apPos.subtype == 2) {
				return buildFloat(-GamepadAtomicPushy$apPos.valueF);
			}
			if (GamepadAtomicPushy$apPos.value) {
				return VALUE_FLOAT_NEGATIVE_ONE;
			}
		}
		return VALUE_FLOAT_ZERO;
	}

	if ((GamepadAtomicPushy$apPos.subtype == 1 || GamepadAtomicPushy$apPos.subtype == 2) && 
		(GamepadAtomicPushy$apNeg.subtype == 1 || GamepadAtomicPushy$apNeg.subtype == 2)) {
		// First check if both axes are analog and if so, use the one that has the strongest value as the other could
		// possibly be non-zero noise.
		if (GamepadAtomicPushy$apPos.valueF > GamepadAtomicPushy$apNeg.valueF) {
			return buildFloat(GamepadAtomicPushy$apPos.valueF);
		}
		return buildFloat(-GamepadAtomicPushy$apNeg.valueF);
	}

	if (GamepadAtomicPushy$apPos.subtype == 1 || GamepadAtomicPushy$apPos.subtype == 2) {
		// positive is analog and negative is not. If negative axis is pressed, return that, otherwise, return the positive axis as-is.
		if (GamepadAtomicPushy$apNeg.value) {
			return VALUE_FLOAT_NEGATIVE_ONE;
		}

		return buildFloat(GamepadAtomicPushy$apPos.valueF);
	}

	if ((GamepadAtomicPushy$apNeg.subtype == 1 || GamepadAtomicPushy$apNeg.subtype == 1)) {
		// negative is analog and positive is not. If positive axis is pressed, return that, otherwise, return the negative axis as-is.
		if (GamepadAtomicPushy$apPos.value) {
			return VALUE_FLOAT_ONE;
		}

		return buildFloat(-1 * GamepadAtomicPushy$apNeg.valueF);
	}

	// Both axes are digital and ideally should be physically impossible to press at the same time, so order doesn't matter.
	if (GamepadAtomicPushy$apPos.value) {
		return VALUE_FLOAT_ONE;
	}
	if (GamepadAtomicPushy$apNeg.value) {
		return VALUE_FLOAT_NEGATIVE_ONE;
	}

	return VALUE_FLOAT_ZERO;
}

function @type('bool') gamepadFireAnalogEvent(
		@type('GamepadStatus') status,
		@type('int') deviceIndex,
		@type('Value') playerId,
		@type('string') pushyDescriptor,
		@type('double') value) {
	
	if (%%%IS_GAMEPAD_SUPPORTED%%%) {
		@type('int') isSignificant = 1;
		if (value < .5) isSignificant = 0;
		@type('Value') gameEvent = buildGameEvent(
			'hardwareanalogaxis',
			'hardware',
			deviceIndex, // x field for device index
			isSignificant, // y field for is_significant
			value,
			false,
			pushyDescriptor,
			playerId);
		$_list_push(GamepadStatus$status.hardwareEvents, gameEvent);
	}
	return true;
}

function @type('bool') gamepadFireDigitalEvent(
		@type('GamepadStatus') status,
		@type('int') deviceIndex,
		@type('Value') playerId,
		@type('string') pushyDescriptor,
		@type('bool') value,
		@type('bool') isDigitalAxis) {
	
	if (%%%IS_GAMEPAD_SUPPORTED%%%) {
		@type('string') type = 'hardwarebutton';
		if (isDigitalAxis) type = 'hardwaredigitalaxis';
		@type('Value') gameEvent = buildGameEvent(
			type,
			'hardware',
			deviceIndex, // x field for device index
			1, // y field for is_significant
			0.0,
			value,
			pushyDescriptor,
			playerId);
		$_list_push(GamepadStatus$status.hardwareEvents, gameEvent);
	}
	return true;
}

// returns -1 if the gamepads have not been initialized.
function @type('int') gamepadGetDeviceCount() {
	
	if (%%%IS_GAMEPAD_SUPPORTED%%%) {
		@type('GamepadStatus') status = gamepadGetGlobalStatus();
		if (GamepadStatus$status.isInitialized) {
			return $_list_length(GamepadStatus$status.devices);
		}
		return -1;
	} else {
		return 0;
	}
}

/*
	Gamepad config file format
	filename: .crayon-gamepad-csotk.config { csotk, pygame, js }
	CONFIG_FINGERPRINT,pushy1,pushy2,...
	individual pushy configs are a | delimited list of the following:
	- 0 or 1 for int or string ID
	- the ID value (for strings, hex encoded)
	- dimensionality
	- 0 or 1 for isDigital
	- a list of the atomic pushy configuration ID's OR an empty string

	The save config builds a list of these configurations per gamepad. 
	When it encounters a configuration it saves its config fingerprint in a set (dictionary of string to ignored-bool)
	After looping through current devices, it loads the config file and appends all configs that aren't currently set to the end of the list
	It resaves the list (\n delimited) to the file again.
*/
function @type('int') gamepadSaveConfig(
		@type('Array<string>') stringOutParam) { // outParam used internally by the io stuff.
	@type('GamepadStatus') status = gamepadGetGlobalStatus();
	if (!GamepadStatus$status.isInitialized) {
		return 1;
	}
	if (%%%IS_GAMEPAD_SUPPORTED%%%) {
		@type('int') j = 0;
		@type('int') i = 0;
		@type('Dictionary<string, bool>') gamepadsConfigured = $_new_dictionary('string', 'bool');
		@type('List<GamepadDeviceInfo>') gamepads = GamepadStatus$status.devices;
		@type('List<GamepadDeviceInfo>') registeredGamepads = $_new_list('GamepadDeviceInfo');
		@type('List<GamepadDeviceInfo>') unregisteredGamepads = $_new_list('GamepadDeviceInfo');
		@type('GamepadDeviceInfo') gamepad = null;
		for (i = 0; i < $_list_length(gamepads); i += 1) {
			gamepad = $_list_get(gamepads, i);
			if (GamepadDeviceInfo$gamepad.playerId != null) {
				$_list_push(registeredGamepads, gamepad);
			} else {
				$_list_push(unregisteredGamepads, gamepad);
			}
		}

		gamepads = registeredGamepads;
		for (i = 0; i < $_list_length(unregisteredGamepads); i += 1) {
			$_list_push(gamepads, $_list_get(unregisteredGamepads, i));
		}

		@type('List<GamepadAtomicPushy>') atomicPushies = GamepadStatus$status.atomicPushies;
		@type('List<string>') fileBuilder = $_new_list('string');
		for (i = 0; i < $_list_length(gamepads); i += 1) {
			gamepad = $_list_get(gamepads, i);
			@type('string') gamepadId = GamepadDeviceInfo$gamepad.configFingerprint;
			@type('List<GamepadVirtualPushy>') virtualPushies = $_new_list('GamepadVirtualPushy');
			for (j = 0; j < $_list_length(GamepadDeviceInfo$gamepad.stringVirtualPushyIds); j += 1) {
				@type('string') sPushyId = $_list_get(GamepadDeviceInfo$gamepad.stringVirtualPushyIds, j);
				$_list_push(virtualPushies, $_dictionary_get_guaranteed(GamepadDeviceInfo$gamepad.stringVirtualPushies, sPushyId));
			}
			for (j = 0; j < $_list_length(GamepadDeviceInfo$gamepad.intVirtualPushyIds); j += 1) {
				@type('int') iPushyId = $_list_get(GamepadDeviceInfo$gamepad.intVirtualPushyIds, j);
				$_list_push(virtualPushies, $_dictionary_get_guaranteed(GamepadDeviceInfo$gamepad.intVirtualPushies, iPushyId));
			}

			if ($_list_length(virtualPushies) > 0) {
				// gamepad fingerprint (constant value generated from the reported name of the gamepad and its pushy type counts)
				$_list_push(fileBuilder, gamepadId);
				$_dictionary_set(gamepadsConfigured, gamepadId, true);
				for (j = 0; j < $_list_length(virtualPushies); j += 1) {
					@type('GamepadVirtualPushy') virtualPushy = $_list_get(virtualPushies, j);
					@type('Value') alias = GamepadVirtualPushy$virtualPushy.alias;
					@type('int') dimensionality = GamepadVirtualPushy$virtualPushy.dimensionality;
					@type('bool') isDigital = GamepadVirtualPushy$virtualPushy.isDigital;

					$_list_push(fileBuilder, ",");
					if (Value$alias.type == Types.INTEGER) {
						$_list_push(fileBuilder, "0|");
						$_list_push(fileBuilder, $_string_cast_strong($_cast('int', Value$alias.internalValue)));
					} else {
						$_list_push(fileBuilder, "1|");
						$_list_push(fileBuilder, stringToHex($_cast('string', Value$alias.internalValue)));
					}
					$_list_push(fileBuilder, "|");
					$_list_push(fileBuilder, $_string_cast_strong(dimensionality));
					if (isDigital) {
						$_list_push(fileBuilder, "|1");
					} else {
						$_list_push(fileBuilder, "|0");
					}
					
					@type('GamepadAtomicPushy') ap1 = null;
					@type('GamepadAtomicPushy') ap2 = null;
					@type('GamepadAtomicPushy') ap3 = null;
					@type('GamepadAtomicPushy') ap4 = null;
					if (GamepadVirtualPushy$virtualPushy.atomicIndex1 != -1) ap1 = $_list_get(atomicPushies, GamepadVirtualPushy$virtualPushy.atomicIndex1);
					if (GamepadVirtualPushy$virtualPushy.atomicIndex2 != -1) ap2 = $_list_get(atomicPushies, GamepadVirtualPushy$virtualPushy.atomicIndex2);
					if (GamepadVirtualPushy$virtualPushy.atomicIndex3 != -1) ap3 = $_list_get(atomicPushies, GamepadVirtualPushy$virtualPushy.atomicIndex3);
					if (GamepadVirtualPushy$virtualPushy.atomicIndex4 != -1) ap4 = $_list_get(atomicPushies, GamepadVirtualPushy$virtualPushy.atomicIndex4);
					
					$_list_push(fileBuilder, "|");
					if (ap1 != null) {
						$_list_push(fileBuilder, GamepadAtomicPushy$ap1.descriptorId);
					}

					if (dimensionality > 0) {
						$_list_push(fileBuilder, "|");
						if (ap2 != null) {
							$_list_push(fileBuilder, GamepadAtomicPushy$ap2.descriptorId);
						}
						
						if (dimensionality > 1) {
							$_list_push(fileBuilder, "|");
							if (ap3 != null) {
								$_list_push(fileBuilder, GamepadAtomicPushy$ap3.descriptorId);
							}
							$_list_push(fileBuilder, "|");
							if (ap4 != null) {
								$_list_push(fileBuilder, GamepadAtomicPushy$ap4.descriptorId);
							}
						}
					}
				}
				$_list_push(fileBuilder, "\n");
			}
		}

		if ($_list_length(fileBuilder) > 0) {
			@type('string') filepath = gamepadGetConfigFile();
			@type('int') fileReadStatus = ioReadFileText(filepath, true, false, stringOutParam);
			if (fileReadStatus == 0) {
				// not found not triggered.
				@type('string') content = $_array_get(stringOutParam, 0);
				@type('Array<string>') lines = $_string_split(content, "\n");
				for (i = 0; i < $_array_length(lines); i += 1) {
					@type('string') line = $_array_get(lines, i);
					line = $_string_trim(line);
					if ($_string_length(line) > 0) {
						@type('Array<string>') parts = $_string_split(line, ",");
						if ($_array_length(parts) > 1) {
							@type('string') existingGamepadId = $_array_get(parts, 0);
							if (!$_dictionary_contains(gamepadsConfigured, existingGamepadId)) {
								$_list_push(fileBuilder, line);
								$_list_push(fileBuilder, "\n");
								$_dictionary_set(gamepadsConfigured, existingGamepadId, true);
							}
						}
					}
				}
			}
			
			// Ignore error code. If this fails, it should do so silently.
			ioWriteFileText(filepath, $_list_join(fileBuilder, ""), true, false, stringOutParam);
		}
	}
	return 0;
}

function @type('string') gamepadGetConfigFile() {
	return ".crayon-gamepad-%%%PLATFORM_SHORT_ID%%%.config";
}

/* 
	intOutParam[0] -> error code
	error codes:
	0 - no error
	1 - too early
	2 - not an integer
	3 - out of range

	returns a Value containing the native object wrapping the GamepadDeviceInfo.
*/
function @type('Value') gamepadGetDevice(@type('Value') indexValue, @type('Array<int>') intOutParam) {

	@type('GamepadStatus') status = gamepadGetGlobalStatus();
	if (!GamepadStatus$status.isInitialized) {
		$_array_set(intOutParam, 0, 1);
		return null;
	}
	
	if (Value$indexValue.type != Types.INTEGER) {
		$_array_set(intOutParam, 0, 2);
		return null;
	}
	@type('int') index = $_cast('int', Value$indexValue.internalValue);
	
	if (index < 0 || index >= $_list_length(GamepadStatus$status.devices)) {
		$_array_set(intOutParam, 0, 3);
		return null;
	}
	
	$_array_set(intOutParam, 0, 0);
	return $_list_get(GamepadStatus$status.deviceValues, index);
}

/*
	Parses the config file for this platform in user data.
	Tries to initialize as many plugged in devices as possible by going down the history of the most
	recently used devices that have configuration information and applies those in the order it sees.
	
	Returns the number of devices successfully initialized.
	Error code is returned in intOutParam[0]
	
	Error codes:
	0 - no error
	1 - called too early
	2 - idOrList was invalid
*/
function @type('int') gamepadEnableRecent(@type('Value') idOrList, @type('Array<int>') intOutParam, @type('Array<string>') stringOutParam) {
	
	@type('GamepadStatus') status = gamepadGetGlobalStatus();
	if (!GamepadStatus$status.isInitialized) {
		$_array_set(intOutParam, 0, 1);
		return 0;
	}

	if (%%%IS_GAMEPAD_SUPPORTED%%%) {
		
		@type('string') filepath = gamepadGetConfigFile();
		@type('int') fileReadStatus = ioReadFileText(filepath, true, false, stringOutParam);
		if (fileReadStatus == 0) {
			@type('int') i = 0;
			@type('int') j = 0;
			@type('int') gamepadsLoaded = 0;
			@type('List<Value>') idList = null;
			@type('Value') idValue = null;
			@type('Value') aliasValue = null;
			if (Value$idOrList.type == Types.INTEGER || Value$idOrList.type == Types.STRING) {
				idList = $_new_list('Value');
				$_list_push(idList, idOrList);
			} else if (Value$idOrList.type == Types.LIST) {
				idList = $_cast('List<Value>', Value$idOrList.internalValue);
				for (i = 0; i < $_list_length(idList); i += 1) {
					idValue = $_list_get(idList, i);
					if (Value$idValue.type != Types.INTEGER && Value$idValue.type != Types.STRING) {
						$_array_set(intOutParam, 0, 2);
						return 0;
					}
				}
			} else {
				$_array_set(intOutParam, 0, 2);
				return 0;
			}
			// not found not triggered.
			@type('List<GamepadDeviceInfo>') devices = GamepadStatus$status.devices;
			@type('string') content = $_array_get(stringOutParam, 0);
			@type('Array<string>') lines = $_string_split(content, "\n");
			for (i = 0; i < $_array_length(lines); i += 1) {
				@type('string') line = $_array_get(lines, i);
				@type('Array<string>') parts = $_string_split(line, ",");
				@type('string') deviceId = $_array_get(parts, 0);
				@type('GamepadDeviceInfo') gamepad = null;
				@type('Value') gamepadAsValue = null;
				// yup, this is quadratic. If a gamepad device ID is common to multiple gamepads, initialize them all with the same config.
				for (j = 0; j < $_list_length(devices); j += 1) {
					gamepad = $_list_get(devices, j);
					if ($_string_equals(GamepadDeviceInfo$gamepad.configFingerprint, deviceId)) {
						gamepadAsValue = $_list_get(GamepadStatus$status.deviceValues, j);
						/*
							Gamepad config file format (COPIED FROM SAVE CONFIG IMPLEMENTATION)
							filename: .crayon-gamepad-csotk.config { csotk, pygame, js }
							CONFIG_FINGERPRINT,pushy1,pushy2,...
							individual pushy configs are a | delimited list of the following:
							- 0 or 1 for int or string ID
							- the ID value (for strings, hex encoded)
							- dimensionality
							- 0 or 1 for isDigital
							- a list of the atomic pushy configuration ID's OR an empty string
						*/
						if (gamepadsLoaded < $_list_length(idList)) {
							gamepadSetId(gamepadAsValue, $_list_get(idList, gamepadsLoaded));
							gamepadsLoaded += 1;
						}
						// even if a gamepad does not have an ID set, you should still initialize the buttons.

						for (j = 1; j < $_array_length(parts); j += 1) {
							@type('Array<string>') pushyConfigParts = $_string_split($_array_get(parts, j), "|");
							if ($_array_length(pushyConfigParts) > 2) {
								@type('bool') isPushyString = $_string_equals($_array_get(pushyConfigParts, 0), "1");
								@type('string') rawPushyAlias = stringFromHex($_array_get(pushyConfigParts, 1));
								aliasValue = null;
								if (isPushyString) {
									if (rawPushyAlias != null) aliasValue = buildCommonString(rawPushyAlias);
								} else {
									@type('int') t = parsePosDecInt(rawPushyAlias);
									if (t != -1) aliasValue = buildInteger(t);
								}
								@type('int') dimensionality = parsePosDecInt($_array_get(pushyConfigParts, 2));
								@type('bool') isDigital = $_string_equals($_array_get(pushyConfigParts, 3), "1");
								if (aliasValue != null) {
									if ((dimensionality == 0 && $_array_length(pushyConfigParts) == 5) ||
										(dimensionality == 1 && $_array_length(pushyConfigParts) == 6) ||
										(dimensionality == 2 && $_array_length(pushyConfigParts) == 8)) {
									
										for (@type('int') k = 4; k < $_array_length(pushyConfigParts); k += 1) {
											@type('string') pushyConfigDescriptor = $_array_get(pushyConfigParts, k);
											if ($_string_length(pushyConfigDescriptor) > 0) {
												@type('Value') isXValue = null;
												@type('Value') isPos = null;
												if (dimensionality > 1) {
													if (k < 6) isXValue = VALUE_TRUE;
													else isXValue = VALUE_FALSE;
												}
												if (dimensionality > 0) {
													if (k == 4 || k == 6) isPos = VALUE_TRUE;
													else isPos = VALUE_FALSE;
												}
												gamepadBind(
													gamepadAsValue,
													buildString(pushyConfigDescriptor),
													aliasValue,
													dimensionality,
													isPos,
													isXValue,
													isDigital);
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	$_array_set(intOutParam, 0, 0);
	return 0;
}

function @type('bool') gamepadClearBindings(@type('Value') wrappedGamepad) {
	if (%%%IS_GAMEPAD_SUPPORTED%%%) {
		@type('GamepadDeviceInfo') gamepad = $_cast('GamepadDeviceInfo', extractNativeObjectOfType(wrappedGamepad, NativeObjectSubType.GAMEPAD_DEVICE));
		if (gamepad != null) {
			@type('GamepadStatus') status = gamepadGetGlobalStatus();
			@type('List<GamepadAtomicPushy>') atomicPushies = GamepadStatus$status.atomicPushies;
			@type('int') apStart = GamepadDeviceInfo$gamepad.atomicPushyStartIndex;
			@type('int') apEnd = GamepadDeviceInfo$gamepad.atomicPushyCount + apStart;
			for (@type('int') i = apStart; i < apEnd; i += 1) {
				@type('GamepadAtomicPushy') ap = $_list_get(atomicPushies, i);
				GamepadAtomicPushy$ap.isConfigured = false;
			}

			GamepadDeviceInfo$gamepad.stringVirtualPushies = $_new_dictionary('string', 'GamepadVirtualPushy');
			GamepadDeviceInfo$gamepad.intVirtualPushies = $_new_dictionary('int', 'GamepadVirtualPushy');
			$_list_clear(GamepadDeviceInfo$gamepad.stringVirtualPushyIds);
			$_list_clear(GamepadDeviceInfo$gamepad.intVirtualPushyIds);
			return true;
		}
	}
	return false;
}

/*
	status codes:
	- 0 - OK
	- 1 - too early
	- 2 - bad device arg (not a device or string or int)
	- 3 - bad alias arg (not a string or int
*/
function @type('GamepadVirtualPushy') gamepadGetVirtualPushy(@type('Value') deviceOrPlayerValue, @type('Value') aliasValue, @type('Array<int>') intOutParam) {
	@type('GamepadStatus') status = gamepadGetGlobalStatus();
	if (!GamepadStatus$status.isInitialized) {
		$_array_set(intOutParam, 0, 1);
		return null;
	}

	$_array_set(intOutParam, 0, 0);
	if (%%%IS_GAMEPAD_SUPPORTED%%%) {
		
		@type('int') i = 0; 
		@type('GamepadDeviceInfo') device = null;
		if (Value$deviceOrPlayerValue.type == Types.NATIVE_OBJECT) {
			device = $_cast('GamepadDeviceInfo', extractNativeObjectOfType(deviceOrPlayerValue, NativeObjectSubType.GAMEPAD_DEVICE));
			if (device == null) {
				$_array_set(intOutParam, 0, 2);
				return null;
			}
		} else if (Value$deviceOrPlayerValue.type == Types.INTEGER || Value$deviceOrPlayerValue.type == Types.STRING) {
			@type('List<GamepadDeviceInfo>') devices = GamepadStatus$status.devices;
			@type('GamepadDeviceInfo') deviceIterator = null;
			@type('Value') deviceIdValue = null;
			for (i = 0; i < $_list_length(devices); i += 1) {
				deviceIterator = $_list_get(devices, i);
				deviceIdValue = GamepadDeviceInfo$deviceIterator.playerId;
				if (deviceIdValue != null && Value$deviceIdValue.type == Value$deviceOrPlayerValue.type) {
					if (Value$deviceOrPlayerValue.type == Types.INTEGER) {
						if ($_cast('int', Value$deviceOrPlayerValue.internalValue) == $_cast('int', Value$deviceIdValue.internalValue)) {
							device = deviceIterator;
							i += 9999;
						}
					} else {
						if ($_string_equals($_cast('string', Value$deviceOrPlayerValue.internalValue), $_cast('string', Value$deviceIdValue.internalValue))) {
							device = deviceIterator;
							i += 9999;
						}
					}
				}
			}
		} else {
			$_array_set(intOutParam, 0, 2);
			return null;
		}

		// even if the device is null, run through the following logic with device != null checks to give the 
		// arg checker a chance to throw an error rather than fail silently.

		if (Value$aliasValue.type == Types.INTEGER) {
			i = $_cast('int', Value$aliasValue.internalValue);
			if (device != null && $_dictionary_contains(GamepadDeviceInfo$device.intVirtualPushies, i)) {
				return $_dictionary_get_guaranteed(GamepadDeviceInfo$device.intVirtualPushies, i);
			}
		} else if (Value$aliasValue.type == Types.STRING) {
			@type('string') s = $_cast('string', Value$aliasValue.internalValue);
			if (device != null && $_dictionary_contains(GamepadDeviceInfo$device.stringVirtualPushies, s)) {
				return $_dictionary_get_guaranteed(GamepadDeviceInfo$device.stringVirtualPushies, s);
			}
		} else {
			$_array_set(intOutParam, 0, 3);
		}
	}
	return null;
}

// gamepadGetVirtualPushy status codes are intenionally relayed back to framework function call.
function @type('Value') gamepadGetPushyState(@type('Value') deviceOrPlayerValue, @type('Value') aliasValue, @type('Array<int>') intOutParam) {

	@type('GamepadVirtualPushy') virtualPushy = gamepadGetVirtualPushy(deviceOrPlayerValue, aliasValue, intOutParam);

	if (virtualPushy != null) {
		return gamepadGetVirtualPushyValueWithIndex(
			GamepadVirtualPushy$virtualPushy.dimensionality,
			GamepadVirtualPushy$virtualPushy.isDigital,
			GamepadVirtualPushy$virtualPushy.atomicIndex1,
			GamepadVirtualPushy$virtualPushy.atomicIndex2,
			GamepadVirtualPushy$virtualPushy.atomicIndex3,
			GamepadVirtualPushy$virtualPushy.atomicIndex4);
	}
	return VALUE_NULL;
}

function @type('bool') gamepadIsPushyChangedRecently(@type('Value') deviceOrPlayerValue, @type('Value') aliasValue, @type('Array<int>') intOutParam, @type('int') gameCounter) {
	
	@type('GamepadVirtualPushy') virtualPushy = gamepadGetVirtualPushy(deviceOrPlayerValue, aliasValue, intOutParam);

	if (virtualPushy != null) {
		return GamepadVirtualPushy$virtualPushy.gameCounter == gameCounter;
	}
	return false;
}
