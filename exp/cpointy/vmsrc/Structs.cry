struct Code {
	@type('Array<int>') ops,
	@type('Array<Array<int>>') args,
	@type('Array<string>') stringArgs
}

// Dictionaries in Crayon can only have 3 types of keys: integers, strings, and objects
// Dictionaries can hold any of these, but only hold one type at a time
struct DictImpl {
	@type('Dictionary<int, Value>') keyIntLookup,
	@type('Dictionary<int, Value>') valueIntLookup,
	@type('Dictionary<string, Value>') keyStringLookup,
	@type('Dictionary<string, Value>') valueStringLookup,
	@type('int') size,
	@type('int') keyType
}

struct SpriteSheetItemDescriptor {
	@type('string') filePath,
	@type('int') groupId,
	@type('int') spillId,
	@type('int') tileId,
	@type('bool') solitary,
	@type('int') x,
	@type('int') y,
	@type('int') width,
	@type('int') height
}

struct SpriteSheetData {
	@type('Dictionary<string, SpriteSheetItemDescriptor>') files,
	@type('Dictionary<int, List<string>>') filesByGroupId,
	@type('Dictionary<int, Dictionary<int, bool>>') tileIdsByGroupId,
	@type('Dictionary<string, int>') groupIdsByName
}

struct ProgramData {
	@type('StackFrame') stackTop,
	@type('Array<int>') ops,
	@type('Array<Array<int>>') args,
	@type('Array<string>') stringArgs,
	@type('Array<Array<int>>') specialCache,
	@type('Array<string>') identifiers,
	@type('List<string>') identifiersBuilder,
	@type('Dictionary<string, int>') inv_identifiers,
	@type('Array<Value>') literalTable,
	@type('List<Value>') literalTableBuilder,
	@type('Array<ClassInfo>') classTable,
	@type('Array<Dictionary<int, MethodDefinition>>') classMethods,
	@type('bool') tickerRegistered,
	@type('Array<List<Token>>') tokenData,
	@type('int') userCodeStart,
	@type('Dictionary<int, Value>') globalVarScope,
	@type('Array<string>') sourceCode,
	@type('List<string>') sourceCodeBuilder,
	@type('Array<Dictionary<int, int>>') integerSwitchLookups,
	@type('List<Dictionary<int, int>>') integerSwitchLookupsBuilder,
	@type('Array<Dictionary<string, int>>') stringSwitchLookups,
	@type('List<Dictionary<string, int>>') stringSwitchLookupsBuilder,
	@type('Array<int>') primitiveMethodIdLookup,
	@type('int') instanceCounter,
	@type('SpriteSheetData') spriteSheetData,
	@type('ImageSheetStatus') imageSheetStatus,
	@type('SoundStatus') soundStatus,
	@type('bool') initializationComplete,
	@type('GamepadStatus') gamepadStatus,
	@type('int') gameCounter,

	@type('int') valueStackSize,
	@type('int') valueStackCapacity,
	@type('Array<Value>') valueStack,
}

struct StackFrame {
	@type('int') pc,
	@type('Dictionary<int, Value>') locals,
	@type('Array<Value>') args,
	@type('StackFrame') previous,
	@type('bool') returnValueUsed,
	@type('Value') objectContext,
	@type('int') valueStackSize,
}

struct Token {
	@type('int') lineIndex,
	@type('int') colIndex,
	@type('int') fileId
}

struct Value {
	@type('int') type,
	@type('object') internalValue
}

struct MethodInstance {
	@type('Value') context,
	@type('int') pc,
	@type('int') maxArgs
}

struct MethodDefinition {
	@type('int') nameId,
	@type('int') maxArgs,
	@type('int') pc
}

struct SystemMethod {
	@type('Value') context,
	@type('int') id
}

struct ClassInfo {
	@type('int') nameId,
	@type('int') constructorPc,
	@type('int') constructorMaxArgCount,
	@type('int') baseClassId,
	@type('bool') baseConstructorRequired,
	@type('bool') initialized
}

struct FunctionDefinition {
	@type('int') pc,
	@type('int') maxArgCount,
	@type('string') name
}

struct ObjectInstance {
	@type('int') classId,
	@type('Dictionary<int, Value>') fields,
	@type('int') objectId
}

struct CompositeImage {
	@type('object') nativeBitmap,
	@type('int') width,
	@type('int') height,
	@type('int') glTextureId,
	@type('bool') loaded
}

struct ImageSheetVirtualizationGrid {
	@type('Dictionary<string, Array<int>>') imageLocations,
	@type('Dictionary<int, CompositeImage>') sheets,
	@type('string') groupName,
	@type('int') groupId,
	@type('Array<string>') paths,
	@type('bool') loadCompletionChecked
}

/*
 * Either compositeResource or rawResource will be null depending on the platform.
 */
struct Image {
	@type('CompositeImage') compositeResource, // Composite image this image is located in
	@type('object') rawResource, // native platform bitmap if image compositing is not used
	@type('int') sourceX,
	@type('int') sourceY,
	@type('int') sourceWidth,
	@type('int') sourceHeight,
	@type('int') width,
	@type('int') height,
	@type('float') textureLeft,
	@type('float') textureTop,
	@type('float') textureRight,
	@type('float') textureBottom
}

struct ImageSheetStatus {
	@type('Dictionary<string, string>') autogeneratedAsyncDownloadKeyToUserKeyLoop,
	@type('Dictionary<string, object>') downloadedImagesByKey,
	@type('Dictionary<string, int>') downloadedImagesErrorCodes,
	@type('Dictionary<string, TileLoadRequest>') downloadsInFlight, // key is generated tile name
	@type('Dictionary<string, ImageSheetVirtualizationGrid>') fileToVirtualizationGrid,
	@type('Dictionary<int, Array<string>>') generatedTileNamesByGroupId,
	@type('Dictionary<string, int>') groupNameToId,
	@type('bool') isBackgroundLoaderActive,
	@type('Dictionary<string, Image>') loadedImagesByKey,
	@type('Dictionary<string, CompositeImage>') resourceImagesByKeys,
	@type('Dictionary<int, int>') sheetStatus,
	@type('Dictionary<int, List<SpriteSheetItemDescriptor>>') spriteSheetItemDescriptorsByGroupId,
	@type('Dictionary<string, Array<int>>') texturePartitioningInformation,
	@type('List<TileLoadRequest>') tileLoadQueue,
	@type('Dictionary<string, object>') tilesByName,
	@type('Dictionary<int, Array<int>>') tilesPerId,
	@type('Dictionary<string, ImageSheetVirtualizationGrid>') virtualizationGrids
}

struct SoundInstance {
	@type('string') userFilePath, // path in the original project (consistent across platforms)
	@type('object') nativeObject, // native sound object.
	@type('string') realFilePath, // path on the actual disk
	@type('double') volume, // volume for this particular music instance (combined with master volume)
	@type('bool') isLoaded, // true if the music is loaded and ready to play
}

struct MusicInstance {
	@type('string') userFilePath, // path in the original project (consistent across platforms)
	@type('object') nativeObject, // native sound object, if necessary (SDL platforms use file paths directly, so this will be null)
	@type('string') realFilePath, // path on the actual disk
	@type('double') volume, // volume for this particular music instance (combined with master volume)
	@type('bool') isLoaded, // true if the music is loaded and ready to play (for SDL, this is unknown and is assumed to be true despite the fact that it may take a few ticks to start playing)
}

// Enqueued in the SoundStatus.soundEventQueue
// Dequeued by the work unit pump
// If the sound or music for an event isn't loaded, it'll 
struct SoundEvent {
	@type('int') type, // FADE_MUSIC, PLAY_MUSIC, PAUSE_MUSIC, PLAY_SOUND
	@type('SoundInstance') sound, 
	@type('MusicInstance') music,
	@type('bool') fadeOutEstablished, // set to true once the endFade timestamp is established.
	@type('bool') musicLoops, // true if the music should loop.

	// These are set when the event is created. These are in seconds.
	@type('double') fadeOutDuration, 

	// These are all blank when the event is created. 
	// When the music has loaded, these are set to the relative timestamps from the current time using the
	// durations listed above. These are all 1970 epoch timestamps.
	@type('double') fadeStart,
	@type('double') fadeMiddle,
	@type('double') fadeEnd,
}

struct SoundStatus {
	@type('List<SoundEvent>') soundEventQueue,
	@type('MusicInstance') currentMusic,
	@type('double') masterSoundVolume,
	@type('double') masterMusicVolume,
	@type('double') fadeVolumeRatio,
	@type('double') lastSetMusicVolume,
	@type('bool') forceVolumeSet,
}

struct TileLoadRequest {
	@type('string') path,
	@type('int') status,
	@type('int') groupId,
	@type('string') groupName,
	@type('int') tileId,
	@type('object') nativeResource,
	@type('string') asyncReferenceKey, // for JS, the key for which to refer back to the downloader.
}

/*
 * The imagette is an image that is defined by a width, height, and series of blits of native platform bitmaps.
 * These are used during the compositing phase of the image sheet tile loading. This allows that guts of the code logic to be written
 * in Crayon without the extensive use of native methods. The Imagettes, containing straightforward bitmap data, are then flushed to 
 * native platform bitmaps at the end.
 */
struct Imagette {
	@type('int') width,
	@type('int') height,
	@type('List<object>') nativeBitmaps,
	@type('List<int>') xs,
	@type('List<int>') ys,
}

/*
 * All native objects have this as an internal value.
 * The value field here is the actual native object.
 * This allows the native object to be consistently identified with the subtype marker.
 */
struct NativeObjectWrapper {
	@type('int') subType,
	@type('object') value,
}

/*
 * This is the wrapped native object value used for events.
 */
struct GameEvent {
	@type('string') specificType, // { mouseleftdown | mouserightdown | mouseleftup | mouserightup | mousemove | mousescroll | keydown | keyup | quit-x | quit-altf4 }
	@type('string') vagueType, // { mouse | key | hardware | quit } <-- technically these are redundant information with above, but allow for quick checks to see if specific fields are valid on the event object.
	@type('int') x, // re-used by hardware events for device index
	@type('int') y, // re-used by hardware events for 1 or 0 for is_significant
	@type('double') amount,
	@type('bool') down,
	@type('string') arg, // used for keyboard key, mouse button, or quit type
	@type('Value') argValue, // used for player ID for gamepad hardware events
	@type('Value') argValue2, // used for axis or button value in gamepad events
	@type('Value') argValue3, // used for button alias in gamepad events
}

struct GamepadStatus {
	// Whether the gamepad list has been populated...which happens on $game_initialize_screen
	@type('bool') isInitialized,

	// List of all the gamepads that are available on startup, regardless of whether they are enabled.
	// This list does not change.
	@type('List<GamepadDeviceInfo>') devices,
	@type('List<Value>') deviceValues, // parallel list to above, wrapped as NativeObject Values.
	@type('List<GamepadHardwarePushy>') hardwarePushies,
	@type('List<GamepadAtomicPushy>') atomicPushies,

	// Objects to be added to the event queue.
	@type('List<Value>') hardwareEvents,
	@type('List<Value>') virtualEvents,
}

struct GamepadDeviceInfo {
	// Basic info
	@type('int') deviceIndex,
	@type('object') nativeDevice,
	@type('string') name,
	@type('string') configFingerprint,

	// player ID and enabled state
	@type('Value') playerId, // null indicates the gamepad is not enabled.

	// some hardware information to identify this
	@type('int') axisCount,
	@type('int') hatCount,
	@type('int') buttonCount,

	// where are the pushies defined in the lists?
	@type('int') hardwarePushyStartIndex,
	@type('int') hardwarePushyCount,
	@type('int') atomicPushyStartIndex,
	@type('int') atomicPushyCount,

	// a lookup of pushies by their user defined ID
	@type('Dictionary<string, GamepadVirtualPushy>') stringVirtualPushies,
	@type('Dictionary<int, GamepadVirtualPushy>') intVirtualPushies,
	// the order in which virtual pushies were declared
	@type('List<string>') stringVirtualPushyIds,
	@type('List<int>') intVirtualPushyIds,
}

/*
	The term "pushy" is used instead of "button" because it refers to buttons, axes, and hats, as 
	opposed to just boolean buttons.
	There are 3 kinds of pushies described here:
	- Hardware pushy: an actual button, axis, or hat as described by the hardware driver. i.e. axis #3.
	- Atomic pushy: one specific subcomponent of a hardware pushy that can be identified as one action
	  examples:
		button #4
		hat #2 in the negative X direction
		axis #1 in the positive direction
	- Virtual pushy: a 0, 1, or 2 dimensional description of a collection of pushies that has been given
	  an alias by the user code.
	  examples:
		"jump" -> button #2
		"move" --> X+: Axis #0 in positive direction, X-: Axis #0 in negative direction, Y+: Axis #1 in negative direction, Y-: Axis #1 in positive direction
		"throttle" --> Positive: Hat #0 in positive X direction, Negative: Hat #0 in negative X direction
	
	All pushy types are saved in the GamepadState struct. At the end of each frame, the gamepad update phase occurs.
	
	Pass 1:
	During the update phase, a pass is made over all enabled joysticks which goes through and updates the individual
	hardware pushies. If the value is different, then the hardware pushy is updated to reflect this. Also the clock 
	counter is applied to the hardware pushy to indicate that it has been updated this frame.

	Pass 2:
	After the hardware pushies have been updated, a pass is made over all the atomic pushies. The atomic pushy is checked
	against its hardware pushy counterpart. If the value has changed, a hardware event is added to the next event queue to fire. 
	
	Pass 3:
	A pass is made across all virtual pushies. If any of the constituent atomic pushies that make up the virtual pushy has
	been updated this frame, then a user gamepad event is also added to the event queue.
*/
struct GamepadHardwarePushy {
	@type('int') deviceIndex,
	@type('int') type, // { 0 - button, 1 - axis, 2 - hat }
	@type('int') hardwareIndex, // the 4 in "axis #4"
	@type('bool') buttonValue,
	@type('double') axisValue,
	@type('int') hatXValue,
	@type('int') hatYValue,
	@type('int') buttonGameCounter,
	@type('int') axisPositiveGameCounter,
	@type('int') axisNegativeGameCounter,
	@type('int') hatXPositiveGameCounter,
	@type('int') hatYPositiveGameCounter,
	@type('int') hatXNegativeGameCounter,
	@type('int') hatYNegativeGameCounter,
}

struct GamepadAtomicPushy {
	@type('int') hardwarePushyIndex,
	@type('int') subtype, // {0 - button, 1 - axis+, 2 - axis-, 3 - hat X+, 4 - hat X-, 5 - hat Y+, 6 - hat Y-
	@type('bool') value,
	@type('double') valueF,
	@type('int') gameCounter,
	@type('string') descriptorId, // a string that uniquely identifies the hardware profile of this.
	@type('bool') isConfigured, // true if this is used as a virtual configuration
}

/*
	Virtual Buttons registered as digital will return:
	dim 0 - boolean
	dim 1 - -1, 0, or 1
	dim 2 - a list of size 2 of -1, 0, or 1

	Virtual buttons registered as analog will always return
	dim 0 - float from 0 to 1
	dim 1 - float from -1 to 1
	dim 2 - a list of 2 floats from -1 to 1
*/
struct GamepadVirtualPushy {
	@type('Value') alias, // user-defined int or string denoting this event type
	@type('int') dimensionality, // 0, 1, or 2
	@type('bool') isDigital, // true if this should fire digital events
	@type('int') atomicIndex1, // button, or 1D positive, or 2D X+
	@type('int') atomicIndex2, // 1D negative or 2D X-
	@type('int') atomicIndex3, // 2D Y+
	@type('int') atomicIndex4, // 2D Y-
	@type('int') gameCounter, // most recent game counter of constituents
}

struct HttpRequest {
	@type('int') statusCode,
	@type('string') status,
	@type('Dictionary<string, Array<string>>') headers,
	@type('string') body,
}

struct GlRenderState {
	@type('int') mode,
	@type('int') textureId,
	@type('int') r,
	@type('int') g,
	@type('int') b,
	@type('int') a
}
